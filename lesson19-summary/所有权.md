# 所有权
是 Rust 最独特的特性，他让 Rust 无需 GC 就可以保证内存安全

什么是所有权：
- Rust 的核心特性就是所有权
- 所有程序在运行时都必须管理他们使用的计算机内存的方式
  - 有些语言有垃圾收集机制，在程序运行时，他们会不断的寻找不再使用的内存
  - 在其他语言中。程序员必须显式的分配和释放内存
- Rust 采用了第三种方式：
  - 内存是通过一个所有权系统管理的，其中包含一组编译器在编译时检查的规则
  - 在程序运行时，所有权特性不会减慢程序的运行速度
  
## Stack & Heap
栈内存和堆内存
- 在像 Rust 这样的系统级编程语言里，一个值是在 stack 上还是 heap 上对语言的行为和你为什么要做某些决定是有更大的影响的
- 当你的代码在运行的时候， stack 和 heap 都是你代码可用的内存，但他们的结构很不相同

存储数据
- stack 按值的接收顺序来存储，按相反的顺序移除（LIFO）
  - 添加数据叫压栈
  - 移出数据叫弹栈
- 所有栈上的数据必须有已知的固定的大小
  - 编译时大小未知的数据或运行时大小可能发生变化的数据必须放在 heap 上
- heap 内存的组织性差一些
  - 当你把数据放入 heap 时，会为你请求一块内存
  - 操作系统在 heap 里找到一块空间，把它标记为已用，并返回一个指针，也就是这个空间的地址
  - 这个过程叫做在 heap 上的内存分配
- 把数据压到 stack 比分配 heap 快得多

访问数据
- 访问 heap 上的数据要比 stack 上的数据慢，因为要通过指针才能找到 heap 上的数据

函数调用
- 当代码调用函数时，值被传入函数（也包括指向 heap 的指针），函数本地的变量被压到 stack，当函数结束后，这些值弹出 stack


所有权存在的原因
- 所有权解决的问题：
  - 跟踪代码的哪些部分正在使用 heap 的哪些数据
  - 最小化 heap 上的重复数据量
  - 清理 heap 上的未使用数据
- 一旦你懂了所有权，就不需要经常去想 stack 或 heap 了
- 管理 heap 数据是所有权存在的原因

## 所有权规则
- 每个值都有一个变量，这个变量就是该值的所有者
- 每个值同时只能有一个所有者
- 当所有者超出作用域（scope）时，该值将被删除

变量作用域
- scope 就是程序中一个项目的有效范围


String 类型
- String 比其他基础标量数据类型更复杂
- 字符串字面值：程序里那些手写的字符串值，是不可变的
- 在 heap 上分配，能够存储在编译时未知大小的文本

String 是可修改的，但字符串字面值不可修改：
内存和分配
- 字符串字面值：在编译时就知道大小，文本内容被硬编码到最终的可执行文件
  - 速度快、高效，是因为其不可变性
- String 类型为了保持可变性，在 heap 上分配编内存来保存译时未知大小的字符串内容
  - 操作系统必须在运行时请求内存
  - 当使用完 String 后，要用某种方式返还给操作系统
    - 在有GC 的语言中，GC会清理内存
    - 没有 GC，就需要手动释放
      - 如果忘了，就会浪费内存
      - 如果提前释放，变量就会变得非法
      - 如果释放多次，就会造成严重的bug
- Rust 采用了不同方式，对于一个值来说，当拥有他的变量走出作用域时，内存会立即自动的交还给操作系统


## 变量和数据交互的方式，移动（Move）
- 多个变量可以与同一个数据使用一种独特的方式交互
- 存在 stack 上的类型多次赋值会在 stack 上多次压入，如
  ```rs
    let x = 5;
    let y = x;
  ```
  此时 stack 上有两个 5
- 存在 heap 上的类型却不是这样：如
  ```rs
    let s1 = String::from("hello");
    let s2 = s1;
  ```
  此时两个变量都有一个指针指向 heap 上的字符串，当两个变量都走出作用域时都会尝试释放 heap 上的字符串，此时存在问题：多次释放内存
  为了保证内存安全，Rust 让 s1 失效，s2 创建后 s1 不能使用
- 可以使用 clone 方法针对 heap 上的数据进行复制，但会消耗资源
- 对于 stack 上的值，会自动复制

Copy trait 适用于 stack 上的值，如果一个类型实现了 Copy，那么旧的变量在赋值后任然可用
如果一个类型或其一部分实现了 Drop，那么就不能在实现 Copy


## 所有权与函数
- 在语义上，将值赋值给变量和传递给函数是类似的：
  - 将值传递给函数将发生 移动 或 复制
  - 